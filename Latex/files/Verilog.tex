\chapter{
	پیاده‌سازی سخت‌افزاری 
	\lr{Verilog}
}

\section{
	مقدمه
}

دنیای نرم‌افزار و سخت‌افزار رایانه در نگاه کلی می‌توانند بسیار شبیه به هم باشند، برنامه های نرم‌افزاری، مقادیری را به عنوان ورودی دریافت کرده، سپس طی روند مشخصی محاسباتی روی آنها انجام داده و در نهایت مقادیری را به عنوان خروجی به کاربر خود تحویل می دهند، قطعات سخت‌افزاری نیز دارای 
\lr{port}
هایی برای ارتباط با دنیای خارجی و دریافت ورودی‌ و تحویل خروجی‌های خود می‌باشند و از واحدهای مختلف پردازشی و عملیاتی مختلفی برای محاسبه ی خروجی‌های مناسب تشکیل شده اند. درعمل می‌توان سخت‌افزاری خاص برای اجرای بسیاری از روند های نرم‌افزاری طراحی و پیاده سازی کرد، ساخت سخت‌افزارِ خاصِِ مربوط به یک الگوریتم می تواند کاربرد‌های بسیاری داشته باشد، برای مثال قطعه‌ای که بتواند داده های ورودی را رمزنگاری کند می‌تواند به صورت گسترده برای ذخیره ی اطلاعات به صورت سریع استفاده شود، سخت‌افزار های اختصاصیِ الگوریتم ها سریع و بهینه اند و میتوانند به اجرای هرچه سریع تر روندهای پیچیده‌ای که به الگوریتم مورد نظر وابستگی فراوان دارند کمک کلانی کنند.

همانند بسیاری از الگوریتم‌های رایانه‌ای، الگوریتم تابعِ 
\lr{
	Skein Hashing
}
که در بخش قبل کلیتی از آنرا معرفی کردیم را می توان به صورت سخت افزاری پیاده‌سازی کرد، بدین صورت که قطعه‌ای طراحی و پیاده‌سازی کنیم که ورودی ای به اندازه ی دلخواه مارا دریافت و حاصل درهم‌سازی را به صورت خروجی ای به اندازه ی مورد نظر ما خروجی دهد. بر اساس نیاز و کاربرد ما از این قطعه، اندازه‌ی ورودی و خروجی را می توان ثابت و به مقدار دلخواه درنظر گرفت، سپس قطعه‌ای ثابت با پیاده سازیِ بهینه‌ای برای اندازه های مورد نظر طراحی کرد، یا این که قطعه‌ای  برای ورودی و خروجی های با اندازه های متغیر طراحی و پیاده سازی کرد. همان طور که در بخش قبل توضیح داده شد، تابع درهم‌سازی 
\lr{
	Skein Hashing
}
میتواند ورودی‌ای با اندازه ی دلخواه را دریافت کند و خروجی ای با اندازه‌ی دلخواه تحویل دهد، در این مقاله تمرکز ما روی پیاده سازی سخت‌افزاری حالتی از این تابع می باشد که اندازه ی بلاک های درونی تابع ( حالت درونی تابع ) 
\textbf{۵۱۲ بیت}
و حاصل درهم‌سازی نیز به صورت خروجی ای به اندازه ی 
\textbf{۵۱۲ بیت}
می باشد، این تابع در اصطلاح 
\lr{
	\textit{Skein 512-512}
}
نامیده می‌شود.

مراحل طراحی و پیاده‌سازی سخت‌افزاری یک قطعه معمولا به آن صورت است که برای اطمینان از کارکرد صحیح پیاده‌سازی، موازی با طراحی سخت‌افزاری قطعه، پیاده سازی دیگری از الگوریتم به نام مدل طلایی انجام می‌شود و پس از پایان طراحی‌ها، کارکرد قطعه با مدل طلایی مقایسه می شود تا قطعه‌ی نهایی مشکلی نداشته باشد. در بخش 
\hyperref[chapter:GoldenModel]{\textbf{مدل طلایی}}
به تفصیل درباره‌ی مدل طلایی استفاده شده در این پروژه توضیح داده شده است. در این بخش به پیاده‌سخت‌افزاری این الگوریتم به کمک زبانِ توصیف سخت‌افزارِ 
\lr{Verilog}
می پردازیم.

\pagebreak
\section{
	پیاده‌سازی
}
همان طور که توضیح داده شد، الگوریتم 
\lr{Skein}
از سه بخش اصلی تشکیل می‌شود:
\begin{itemize}
	\item 
	\lr{\textit{\textbf{Threefish}}} 
	یا بلاک های رمزنگاری قابل تنظیم،
	\item
	\lr{
		\textit{
			\textbf{Unique Block Iteration (UBI)}
		}
	}
که یک حالت زنجیره ای است که از
\lr{Threefish}
به صورتی استفاده می کند که ورودیِ ‌به اندازه‌ی دلخواه به خروجی‌ای به اندازه‌ای مشخص تبدیل شود.
\item
\textbf{\lr{\textit{\textbf{Optional Argument System}}} } 
که به الگوریتم توانایی پشتیبانی از بسیاری ویژگی های دلخواه را، بدون افزودن باری اضافه به پیاده سازی الگوریتم می‌دهد.

\end{itemize}

طراحی ای که ما در این پروژه به بررسی‌اش می‌پردازیم، یک طراحی بسیار ساده شده از الگوریتمِ
\lr{Skein 512-512}
می باشد. در این طراحی اندازه ی ورودیِ و خروجی اش ثابت و ۵۱۲ بیت می باشند، و اندازه ی حالت درونی تابع درهم‌سازی نیز دقیقا برابر اندازه‌ی ورودی و خروجی‌هاست، بنابراین در این طراحی اثری از پیاده‌سازی یک 
\lr{UBI}
 پیچیده نیست. علاوه‌ بر این، این پیاده‌سازی، پیاده‌سازی خام خود الگوریتمِ
 \lr{Skein 512-512}
 بوده و هیچ ویژگی اضافی ای را پشتیبانی نمی‌کند، بنابراین اثری از پیاده‌سازی 
\lr{Optional Argument System}
نیز در آن نیست. بنابراین طراحی، صرفا شامل بلاک های رمزنگاری قابل تنظیم بوده، داده‌ی ورودی به صورت مستقیم با این بلاک ها تزریغ شده و خروجی الگوریتم نیز به صورت تقریبا مستقیم از آخرین بلاک دریافت می‌شود.


